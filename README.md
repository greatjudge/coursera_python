# coursera_python Погружение в Python
1 - ый курс из специализации https://www.coursera.org/specializations/programming-in-python

1. Key-value storage
  Данные будут сохраняться в файле storage.data. Добавление новых данных в хранилище и получение текущих значений осуществляется с помощью утилиты командной строки storage.py. Пример работы утилиты:  
  Сохранение значения value по ключу key_name:  $ storage.py --key key_name --val value
  Получение значения по ключу key_name:  $ storage.py --key key_name
  
  Пример работы:
    $ python storage.py --key key_name --val value
    $ python storage.py --key key_name
    value

    $ python storage.py --key multi_key --val value1
    $ python storage.py --key multi_key --val value2
    $ python storage.py --key multi_key
    value1, value2
    
    
2.  Car Base
  Предположим есть данные о разных автомобилях и спецтехнике. Данные представлены в виде таблицы с характеристиками. Вся техника разделена на три вида: спецтехника, легковые и грузовые автомобили. Обратите внимание на то, что некоторые характеристики присущи только определенному виду техники. Например, у легковых автомобилей есть характеристика «кол-во пассажирских мест», а у грузовых автомобилей — габариты кузова: «длина», «ширина» и «высота».
  
    необходимо создать свою иерархию классов для данных, которые описаны в таблице. Классы должны называться CarBase (базовый класс для всех типов машин), Car (легковые автомобили), Truck (грузовые автомобили) и SpecMachine (спецтехника). Все объекты имеют обязательные атрибуты:

  - car_type, значение типа объекта и может принимать одно из значений: «car», «truck», «spec_machine».

  - photo_file_name, имя файла с изображением машины, допустимы названия файлов изображений с расширением из списка: «.jpg», «.jpeg», «.png», «.gif»

  - brand, марка производителя машины

  - carrying, грузоподъемность

  В базовом классе CarBase нужно реализовать метод get_photo_file_ext для получения расширения файла изображения. Расширение файла можно получить при помощи os.path.splitext.

  Для грузового автомобиля необходимо в конструкторе класса определить атрибуты: body_length, body_width, body_height, отвечающие соответственно за габариты кузова — длину, ширину и высоту. Габариты передаются в параметре body_whl (строка, в которой размеры разделены латинской буквой «x»). Обратите внимание на то, что характеристики кузова должны быть вещественными числами и характеристики кузова могут быть не валидными (например, пустая строка). В таком случае всем атрибутам, отвечающим за габариты кузова, присваивается значение равное нулю.

  Также для класса грузового автомобиля необходимо реализовать метод get_body_volume, возвращающий объем кузова.

  В классе Car должен быть определен атрибут passenger_seats_count (количество пассажирских мест), а в классе SpecMachine — extra (дополнительное описание машины).
  
  	                  Car  	Truck  	SpecMachine
    car_type	            1	    1       	1
    photo_file_name	      1	    1       	1
    brand	                1   	1	        1
    carrying	            1 	  1       	1
    passenger_seats_count	1	    0	        0
    body_width	          0   	1	        0
    body_height	          0    	1       	0
    body_length	          0	    1       	0
    extra	                0    	0       	1

Функцию get_car_list, на вход которой подается имя файла в формате csv. Файл содержит данные, аналогичные строкам из таблицы. Вам необходимо прочитать этот файл построчно при помощи модуля стандартной библиотеки csv. Затем проанализировать строки на валидность и создать список объектов с автомобилями и специальной техникой. Функция должна возвращать список объектов.
  
  
3.  Клиент для отправки метрик

  3.1 Протокол взаимодействия.
    Клиент и сервер взаимодействуют между собой по простому текстовому протоколу через TCP сокеты. Текстовый протокол имеет главное преимущество – наглядность, можно просматривать диалог взаимодействия клиентской и серверной стороны без использования дополнительных инструментов.
    Общий формат запросов и ответов.

Протокол поддерживает два вида запросов к серверу со стороны клиента:

    - отправка данных для сохранения их на сервере

    - получения сохраненных данных

Общий формат запроса клиента:  <команда> <данные запроса><\n>
      - <команда> - команда сервера (команда может принимать одно из двух значений: put — сохранить данные на сервере, get — вернуть сохраненные данные с сервера),

      - <данные запроса> - данные запроса (их формат мы подробно разберем ниже в примере),

      - <\n> - символ переноса строки.

Необходимо реализовать класс Client, в котором будет инкапсулировано соединение с сервером, клиентский сокет и методы для получения (get) и отправки (put) метрик на сервер. Отправка и получение данных в методах get и put должна быть реализована в соответствии с протоколом, описанным выше. В конструктор класса Client должна передаваться адресная пара хост и порт, а также необязательный аргумент timeout (имеющий значение по умолчанию - None). Соединение с сервером устанавливается при создании экземпляра класса Client  и не должно разрываться между запросами.   

Пример создания объекта клиента и отправки запросов на сервер:

    >>> from solution import Client

    >>> client = Client("127.0.0.1", 8888, timeout=15)

    >>> client.put("palm.cpu", 0.5, timestamp=1150864247)

    >>> client.put("palm.cpu", 2.0, timestamp=1150864248)

    >>> client.put("palm.cpu", 0.5, timestamp=1150864248)

    >>> client.put("eardrum.cpu", 3, timestamp=1150864250)

    >>> client.put("eardrum.cpu", 4, timestamp=1150864251)

    >>> client.put("eardrum.memory", 4200000)

    >>> print(client.get("*"))
    
    
Метод put.

Метод put принимает в качестве параметров: название метрики, численное значение и необязательный именованный параметр timestamp. Если пользователь вызвал метод put без аргумента timestamp, то клиент автоматически должен подставить значение временной отметки, полученное с помощью вызова int(time.time()).

Метод put не возвращает ничего в случае успешной отправки и выбрасывает пользовательское исключение ClientError в случае не успешной.
Метод get.

Метод get принимает в качестве параметра имя метрики, значения которой мы хотим получить. В качестве имени метрики можно использовать символ «*», о котором мы упоминали в описании протокола.

Метод get возвращает словарь с метриками (смотрите пример ниже) в случае успешного получения ответа от сервера и выбрасывает исключение ClientError в случае не успешного.

Клиент получает данные от сервера в текстовом виде, метод get должен обработать строку ответа и вернуть словарь с полученными ключами с сервера. Значением ключей в словаре является список кортежей:

    [(timestamp1, metric_value1), (timestamp2, metric_value2), …]

Значение timestamp и metric_value должны быть преобразованы соответственно к типам int и float. Список должен быть отсортирован по значению timestamp (по возрастанию).

Пример возвращаемого значения при успешном вызове client.get("palm.cpu"):

      {
        'palm.cpu': [
          (1150864247, 0.5),
          (1150864248, 0.5)
        ]
      }

Обратите внимание, что сервер хранит данные с максимальным разрешением в одну секунду. Это означает, что если в одну и ту же секунду отправить две одинаковые метрики, то будет сохранено только одно значение, которое было обработано последним. Все остальные значения будут перезаписаны. По этой причине запрос по ключу "palm.cpu" вернул данные двух измерений.

Пример возвращаемого значения при успешном вызове client.get("*"):

    {
      'palm.cpu': [
        (1150864247, 0.5),
        (1150864248, 0.5)
      ],
      'eardrum.cpu': [
        (1150864250, 3.0),
        (1150864251, 4.0)
      ],
      'eardrum.memory': [
        (1503320872, 4200000.0)
      ]
    }

Если в ответ на get-запрос сервер вернул положительный ответ "ok\n\n", но без данных (то есть данных по запрашиваемому ключу нет), то метод get клиента должен вернуть пустой словарь.

Итак, в качестве решения вам необходимо предоставить модуль с реализованным в нем классом Client, пользовательским исключением ClientError. В классе Client должны быть доступны методы get и put с описанной выше сигнатурой. При вызове методов get и put клиент должен посылать сообщения в TCP-соединение с сервером (в соответствии с описанным текстовым протоколом), получать ответ от сервера и возвращать словарь с данными, в формате описанном выше.  
